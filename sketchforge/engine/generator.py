import os
import re
from pathlib import Path
from typing import List, Tuple, Dict, Any
from jinja2 import FileSystemLoader, select_autoescape
from jinja2.sandbox import SandboxedEnvironment

# Use absolute import to be safe, or keep your relative import if it works
from ..core import Node


class ProjectGenerator:
    def __init__(self, root_path: str):
        self.root_path = Path(root_path)

        # 1. Setup Jinja2 Environment
        # This points to the 'templates' folder inside the package
        template_dir = Path(__file__).parent.parent / "templates"
        self.env = SandboxedEnvironment(
            loader=FileSystemLoader(template_dir),
            autoescape=select_autoescape()
        )


    def generate(self, nodes: List[Node], parent_path: Path = None):
        target_path = parent_path or self.root_path
        if not target_path.exists():
            target_path.mkdir(parents=True, exist_ok=True)

        for node in nodes:
            current_path = target_path / node.name

            if node.is_dir:
                print(f"ðŸ“ {current_path}")
                current_path.mkdir(exist_ok=True)
                self.generate(node.children, current_path)
            else:
                print(f"ðŸ“„ {current_path}")
                content = self._render_content(node)
                self._write_file(current_path, content)

    def _parse_decorator(self, raw_dec: str) -> Tuple[str, List[str]]:
        """
        Parses '@sqlalchemy(User, email)' into ('sqlalchemy', ['User', 'email'])
        """
        # Regex to capture name and arguments inside parentheses
        match = re.match(r"([a-zA-Z0-9_-]+)(?:\((.*)\))?", raw_dec)
        if not match:
            return raw_dec, []

        name = match.group(1)
        args_str = match.group(2)

        args = []
        if args_str:
            # Split by comma and strip whitespace
            args = [a.strip() for a in args_str.split(",")]

        return name, args

    def _render_content(self, node: Node) -> str:
        content = "# Generated by SketchForge\n"

        for dec in node.decorators:
            name, args = self._parse_decorator(dec)
            template_name = f"{name}.j2"

            try:
                template = self.env.get_template(template_name)
                context: Dict[str, Any] = {}

                # --- UNIVERSAL ARGUMENT PARSING ---
                # If the decorator has arguments, assume Arg 1 is ClassName
                # and the rest are Fields.
                if args:
                    class_name = args[0]
                    raw_fields = args[1:]
                    parsed_fields = []

                    for f in raw_fields:
                        # Split "field:type"
                        if ":" in f:
                            f_name, f_type = f.split(":")
                        else:
                            f_name, f_type = f, "str" # Default

                        # --- TYPE MAPPING LOGIC ---
                        # SQLAlchemy needs "String", "Integer"
                        if name == "sqlalchemy":
                            sql_map = {
                                "str": "String", "int": "Integer",
                                "bool": "Boolean", "float": "Float"
                            }
                            f_type = sql_map.get(f_type, "String")

                        # PyTorch/Pydantic use the raw type (e.g., 'linear', 'int')
                        # so we don't change f_type for them.

                        parsed_fields.append({"name": f_name, "type": f_type})

                    context = {
                        "class_name": class_name,
                        "fields": parsed_fields
                    }
                # ----------------------------------

                return template.render(**context)

            except Exception as e:
                # print(f"Template warning: {e}") # Uncomment to debug
                pass

        return content


    def _write_file(self, target_path: Path, content: str):
        # SECURITY CHECK: Path Traversal
        # Ensure the resolved target path starts with the resolved root path
        try:
            # resolve() removes '..' and follows symlinks
            safe_root = self.root_path.resolve()
            safe_target = target_path.resolve()

            # This throws an error if safe_target is not inside safe_root
            safe_target.relative_to(safe_root)

        except ValueError:
            print(f"â›” SECURITY WARNING: Attempted to write outside project root: {target_path}")
            return # Skip this file

        # Proceed with writing
        with open(target_path, "w", encoding="utf-8") as f:
            f.write(content)
